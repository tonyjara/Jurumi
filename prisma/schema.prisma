//generates types based on schema, useful for reference. Do not commit.

generator zod {
  provider              = "zod-prisma"
  output                = "./zod"
  relationModel         = true
  modelCase             = "PascalCase"
  modelSuffix           = "Model"
  useDecimalJs          = true
  imports               = null
  prismaJsonNullability = true
}

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//Tips
// To add new fields, first add them as optionsl next to the type, ex: String?. Then add the missing fields from studio then take the ? out and re run the migration.
// use a .env to store everything, prisma doesn't like the .env.local

model Account {
  id          String    @id @default(cuid())
  active      Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime? @updatedAt
  email       String    @unique
  displayName String    @unique
  password    String
  role        Role      @default(USER)
  isVerified  Boolean   @default(false)

  profile Profile?

  moneyRequests            MoneyRequest[]
  moneyApprovals           MoneyRequestApproval[]
  accountVerificationLinks AccountVerificationLinks[]
  transactions             Transaction[]

  moneyApproverOrgs Organization[] @relation("moneyRequestApprovers")
  moneyAdminOrgs    Organization[] @relation("moneyAdministrators")
  allowedOnProjects Project[]
}

model AccountVerificationLinks {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  createdById      String
  account          Account  @relation(fields: [accountId], references: [id])
  accountId        String
  verificationLink String
  email            String
  hasBeenUsed      Boolean  @default(false)
}

model Profile {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
  avatarUrl String
  account   Account   @relation(fields: [accountId], references: [id])
  accountId String    @unique
}

// Users added here can see all projects
model Organization {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())
  updatedAt   DateTime? @updatedAt
  createdById String
  updatedById String?
  displayName String    @unique

  moneyAccounts MoneyAccount[]
  moneyRequests MoneyRequest[]
  projects      Project[]

  moneyRequestApprovers Account[] @relation("moneyRequestApprovers") //All money requests need to be approved by this users.
  moneyAdministrators   Account[] @relation("moneyAdministrators") //All money requests are executed by this users, the also get notified.
  archived              Boolean   @default(false)
  softDeleted           Boolean   @default(false)
}

//USERS are not allowed access
model MoneyAccount {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime? @updatedAt
  createdById   String
  updatedById   String?
  displayName   String
  isCashAccount Boolean // Used to create a petty cash account.

  currency       Currency @default(PYG)
  initialBalance Decimal  @default(0) @db.Decimal(19, 4)

  imbursements Imbursement[]
  organization Organization[]

  archived    Boolean @default(false)
  softDeleted Boolean @default(false)

  bankInfo     BankInfo?
  transactions Transaction[]
}

model BankInfo {
  bankName           BankNamesPy
  accountNumber      String          @unique
  ownerName          String
  ownerDocType       BankDocType     @default(RUC)
  ownerDoc           String
  ownerContactNumber String?
  country            String
  city               String
  type               BankAccountType @default(SAVINGS)

  moneyAccountId String       @unique
  moneyAccount   MoneyAccount @relation(fields: [moneyAccountId], references: [id], onDelete: Cascade)

  @@unique([bankName, accountNumber])
}

//A project can have several donors. The estimated amount of money for the project is infered from the cost categories assigned.
//The amount of money received is infered from the imbursments from the donors. Once we have assigned donors we can choose from their imbursments and relate them to the project.
model Project {
  id           String    @id @default(cuid())
  createdAt    DateTime  @default(now())
  updatedAt    DateTime? @updatedAt
  createdById  String
  updatedById  String?
  displayName  String    @unique
  description  String
  archived     Boolean   @default(false)
  softDeleted  Boolean   @default(false)
  allowedUsers Account[] // account with USER role that can interact with this project

  moneyRequest   MoneyRequest[]
  costCategories CostCategory[]
  projectStages  ProjectStage[]
  TaxPayer       TaxPayer[]

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id])
}

model ProjectStage {
  id            String        @id @default(cuid())
  createdAt     DateTime      @default(now())
  updatedAt     DateTime?     @updatedAt
  createdById   String
  updatedById   String?
  startDate     DateTime
  endDate       DateTime?
  expectedFunds Decimal       @default(0) @db.Decimal(12, 4)
  donors        TaxPayer[]
  receivedFunds Imbursement[]
  Project       Project?      @relation(fields: [projectId], references: [id])
  projectId     String?
}

model CostCategory {
  id              String         @id @default(cuid())
  createdAt       DateTime       @default(now())
  updatedAt       DateTime?      @updatedAt
  createdById     String
  updatedById     String?
  displayName     String
  currency        Currency
  openingBalance  Decimal        @default(0) @db.Decimal(12, 4)
  projectId       String?
  Project         Project?       @relation(fields: [projectId], references: [id])
  expenseReportId String?
  ExpenseReport   ExpenseReport? @relation(fields: [expenseReportId], references: [id])
}

model Imbursement {
  id                          String    @id @default(cuid())
  createdAt                   DateTime  @default(now())
  updatedAt                   DateTime? @updatedAt
  createdById                 String
  updatedById                 String?
  concept                     String    @unique
  wasConvertedToOtherCurrency Boolean   @default(false)
  exchangeRate                Int
  otherCurrency               Currency
  amountInOtherCurrency       Decimal   @default(0) @db.Decimal(12, 4)
  finalCurrency               Currency  @default(PYG)
  finalAmount                 Decimal   @default(0) @db.Decimal(12, 4)

  archived    Boolean @default(false)
  softDeleted Boolean @default(false)

  taxPayerId     String
  taxPayer       TaxPayer      @relation(fields: [taxPayerId], references: [id])
  ProjectStage   ProjectStage? @relation(fields: [projectStageId], references: [id])
  projectStageId String?

  MoneyAccount   MoneyAccount? @relation(fields: [moneyAccountId], references: [id])
  moneyAccountId String?
  transactions   Transaction[]
}

model TaxPayer {
  id            String          @id @default(cuid())
  createdAt     DateTime        @default(now())
  updatedAt     DateTime?       @updatedAt
  createdById   String
  updatedById   String?
  razonSocial   String          @unique
  ruc           String          @unique
  fantasyName   String?
  imbursements  Imbursement[]
  ExpenseReport ExpenseReport[]

  archived    Boolean @default(false)
  softDeleted Boolean @default(false)

  Project      Project[]
  ProjectStage ProjectStage[]
}

model MoneyRequestApproval {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  status        MoneyResquestApprovalStatus
  rejectMessage String

  accountId      String
  account        Account      @relation(fields: [accountId], references: [id])
  moneyRequestId String
  aoneyRequest   MoneyRequest @relation(fields: [moneyRequestId], references: [id])
}

model MoneyRequest {
  id               String             @id @default(cuid())
  createdAt        DateTime           @default(now())
  updatedAt        DateTime?          @updatedAt
  description      String
  status           MoneyRequestStatus
  moneyRequestType MoneyRequestType
  currency         Currency
  amountRequested  Decimal            @default(0) @db.Decimal(12, 4)
  rejectionMessage String

  accountId      String
  account        Account      @relation(fields: [accountId], references: [id])
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id])

  projectId String?
  project   Project? @relation(fields: [projectId], references: [id])

  ExpenseReports        ExpenseReport[]
  moneyRequestApprovals MoneyRequestApproval[]
  transactions          Transaction[]
  ExpenseReturn         ExpenseReturn[]

  archived    Boolean @default(false)
  softDeleted Boolean @default(false)
}

model ExpenseReport {
  id                String         @id @default(cuid())
  createdAt         DateTime       @default(now())
  updatedAt         DateTime?      @updatedAt
  costCategory      CostCategory[]
  facturaNumber     String
  facturaPictureUrl String
  facturaText       String
  amountSpent       Decimal        @default(0) @db.Decimal(12, 4)

  taxPayerId     String
  taxPayer       TaxPayer      @relation(fields: [taxPayerId], references: [id])
  moneyRequestId String?
  MoneyRequest   MoneyRequest? @relation(fields: [moneyRequestId], references: [id])

  @@unique([taxPayerId, facturaNumber])
}

model ExpenseReturn {
  id                    String    @id @default(cuid())
  createdAt             DateTime  @default(now())
  updatedAt             DateTime? @updatedAt
  amountReturned        Decimal   @default(0) @db.Decimal(12, 4)
  returnProofPictureUrl String

  moneyRequestId String
  MoneyRequest   MoneyRequest  @relation(fields: [moneyRequestId], references: [id])
  transactions   Transaction[]
}

//The only way to add or substract money from moneyaccounts is through a transaction.
model Transaction {
  id                  Int       @id @default(autoincrement())
  createdAt           DateTime  @default(now())
  updatedAt           DateTime? @updatedAt
  updatedById         String?
  currency            Currency
  openingBalance      Decimal   @default(0) @db.Decimal(12, 4)
  transactionAmount   Decimal   @default(0) @db.Decimal(12, 4)
  transactionProofUrl String

  moneyAccountId String
  moneyAccount   MoneyAccount @relation(fields: [moneyAccountId], references: [id])
  account        Account      @relation(fields: [accountId], references: [id])
  accountId      String

  moneyRequestId  String?
  moneyRequest    MoneyRequest?  @relation(fields: [moneyRequestId], references: [id])
  ExpenseReturn   ExpenseReturn? @relation(fields: [expenseReturnId], references: [id])
  expenseReturnId String?
  Imbursement     Imbursement?   @relation(fields: [imbursementId], references: [id])
  imbursementId   String?
}

enum Role {
  ADMIN // full access to crud and testing/seed
  MODERATOR
  // can create everything but not hard delete. 
  // Can change status.
  USER
  // can only see their requests
  // Has to be specificly assigned to read or write.
  // Can't see any amount of money left.
  // Cannot change status.
}

enum BankAccountType {
  SAVINGS
  CURRENT
}

enum BankNamesPy {
  ITAU
  BANCO_GNB
  BANCO_CONTINENTAL
  BANCO_ATLAS
  BANCO_REGIONAL
  BANCO_FAMILIAR
  VISION_BANCO
  BANCO_NACIONAL_DE_FOMENTO
  SUDAMERIS
  BANCO_BASA
  INTERFISA_BANCO
  BANCOP
  BANCO_RIO
  CITIBANK
  BANCO_DO_BRASIL
  BANCO_DE_LA_NACION_ARGENTINA
}

enum BankDocType {
  CI
  CRC
  PASSPORT
  RUC
}

enum Currency {
  USD
  PYG
}

// depends on apporvers approval before being accepted.
enum MoneyRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum MoneyRequestType {
  FUND_REQUEST // user requests for funds which he later needs to justify with pictures, factura names, etc.
  MONEY_ORDER // user to keep track of transfers, for example, we request money to pay accounting.
  REIMBURSMENT_ORDER // user already spent the money and is required a reimbursment of a particular activity. Invoice picture is required.
}

enum MoneyResquestApprovalStatus {
  PENDING
  ACCEPTED
  REJECTED
}
